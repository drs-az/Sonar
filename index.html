<!DOCTYPE html><html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sonar Messenger üê¨</title>
<meta name="theme-color" content="#0b1020" />
<style>
  :root{ --bg:#0b1020; --bg2:#0c1430; --card:#111b3a; --muted:#aab1c7; --ink:#eef2ff; --line:#223066; --accent:#6aa3ff; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--ink);background:radial-gradient(1200px 800px at 50% -10%, #1a2b6d33 0%, transparent 60%),linear-gradient(180deg,var(--bg),var(--bg2) 35%,var(--bg));}
  .container{max-width:980px;margin:0 auto;padding:24px 16px}
  header h1{margin:0;font-size:clamp(22px,3.8vw,32px);font-weight:800;letter-spacing:.2px;display:flex;align-items:center;gap:10px}
  header p{margin:.35rem 0 0;color:var(--muted)}
  .badge{display:inline-flex;gap:8px;align-items:center;background:#0e1a3f;border:1px solid var(--line);border-radius:999px;padding:6px 10px;color:#d9e2ff;font-size:12px;margin:10px 10px 0 0}
  .card{background:var(--card);border:1px solid var(--line);border-radius:18px;box-shadow:0 10px 30px #0005;padding:18px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  @media (max-width:860px){.grid{grid-template-columns:1fr}}
  h2{margin:0 0 8px;font-size:18px}
  .muted{color:var(--muted)}
  textarea, input[type="file"], .text{width:100%}
  textarea{min-height:110px;padding:14px;border-radius:12px;border:1px solid var(--line);background:#0d1634;color:var(--ink);outline:none}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .btn{appearance:none;border:none;border-radius:12px;padding:12px 16px;background:linear-gradient(180deg,#4b87ff,#2a67f7);color:#fff;font-weight:700;cursor:pointer;box-shadow:0 6px 18px #4a87ff55}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .btn.ghost{background:#162650;border:1px solid var(--line);box-shadow:none}
  audio{width:100%}
  .small{font-size:12px;color:var(--muted)}
  .pill{font-size:11px;padding:3px 8px;border-radius:999px;background:#0f1b3c;border:1px solid #263469;color:#cfe0ff;margin-right:6px}
  .kbd{background:#0e1735;border:1px solid #2b3a73;border-radius:6px;padding:2px 6px;font-family:ui-monospace,Menlo,Consolas,monospace;color:#dfe7ff}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .field{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .switch{display:inline-flex;align-items:center;gap:8px}
  .switch input{width:18px;height:18px}
  input[type="password"], input[type="text"]{border-radius:12px;border:1px solid var(--line);background:#0d1634;color:#eef2ff;padding:10px 12px;outline:none}
  .strength-indicator{width:100%;font-size:12px;margin-top:4px;color:var(--muted)}
  .strength-indicator strong{font-weight:600}
  input[type="password"].strength-weak{border-color:#ff6b6b;box-shadow:0 0 0 1px #ff6b6b33 inset}
  input[type="password"].strength-fair{border-color:#f5c542;box-shadow:0 0 0 1px #f5c54233 inset}
  input[type="password"].strength-strong{border-color:#38d996;box-shadow:0 0 0 1px #38d99633 inset}
  input[type="password"].strength-excellent{border-color:#38d996;box-shadow:0 0 0 1px #38d99666 inset}
  .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(5,10,25,0.78);backdrop-filter:blur(6px);z-index:999;padding:20px;animation:fadeIn 0.2s ease-out}
  .modal.hidden{display:none}
  .modal-content{max-width:420px;width:100%;background:var(--card);border:1px solid var(--line);border-radius:16px;box-shadow:0 18px 40px #000a;padding:22px;display:flex;flex-direction:column;gap:16px;animation:slideUp 0.25s ease-out}
  .modal-content h3{margin:0;font-size:18px}
  .modal-content p{margin:0;color:var(--ink)}
  .modal-actions{display:flex;justify-content:flex-end}
  .hidden{display:none !important}
  @keyframes fadeIn{from{opacity:0}to{opacity:1}}
  @keyframes slideUp{from{transform:translateY(16px);opacity:0}to{transform:translateY(0);opacity:1}}
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>
        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M3 12c3-3 6-3 9 0s6 3 9 0" stroke="#6aa3ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Sonar
      </h1>
      <!-- <p class="muted">Create dolphin‚Äëstyle chirp audio from text and decode uploads back to text. <strong>Encryption is required</strong> (AES‚ÄëGCM with passphrase via PBKDF2). Pure HTML + JavaScript. Mobile‚Äëfriendly. No backend.</p> -->
      <span class="badge">Charset: A‚ÄìZ, space, 2‚Äì7</span>
      <span class="badge">44.1 kHz</span>
      <span class="badge">120 ms symbol</span>
      <span class="badge">4‚Äì12 kHz band</span>
      <span class="badge">AES‚ÄëGCM 256 ‚Ä¢ PBKDF2‚ÄëSHA256 (required)</span>
    </header>

<section id="encodeSection">
  <div class="card" style="margin-top:8px">
    <h2>Text ‚Üí Sonar WAV</h2>
    <p class="muted">Type your message. Enter a passphrase to encrypt (required) and generate the WAV. Works offline.</p>
    <textarea id="textIn" placeholder="HELLO WORLD FROM DOM">HELLO WORLD FROM DOM</textarea>
    <div class="field" style="margin-top:10px">
      <label for="encPass" class="small">Passphrase (required)</label>
      <input type="password" id="encPass" placeholder="Enter passphrase" autocomplete="new-password" required />
      <div id="encPassFeedback" class="strength-indicator"></div>
    </div>
    <div class="row" style="margin-top:12px">
      <button id="btnEncode" class="btn">Generate WAV</button>
      <button id="btnPlay" class="btn ghost" disabled>Play</button>
      <a id="downloadLink" class="btn ghost" download="sonar.wav" style="text-decoration:none;display:none">Download WAV</a>
    </div>
    <div style="height:10px"></div>
    <audio id="player" controls></audio>
    <p class="small">Tip: For best decoding, use the saved WAV. MP3 may work but lossy compression can smear high‚Äëfrequency sweeps.</p>
  </div>
</section>

<section id="decodeSection">
  <div class="card" style="margin-top:8px">
    <h2>Audio (WAV/MP3) ‚Üí Decoded Text</h2>
    <p class="muted">Upload a file produced by this encoder. <strong>Enter the same passphrase</strong> to decrypt and reveal the text.</p>
    <input type="file" id="fileIn" accept="audio/*" />
    <div class="field" style="margin-top:10px">
      <label for="decPass" class="small">Passphrase (required)</label>
      <input type="password" id="decPass" placeholder="Enter passphrase" autocomplete="current-password" required />
      <div id="decPassFeedback" class="strength-indicator"></div>
    </div>
    <div class="row" style="margin-top:12px">
      <button id="btnDecode" class="btn" disabled>Decode</button>
    </div>
    <div style="height:10px"></div>
    <div class="pill">Decoded text</div>
    <pre id="decoded" class="mono" style="white-space:pre-wrap;min-height:80px"></pre>
  </div>
</section>

<section class="card" style="margin-top:16px">
  <h2>How it works</h2>
  <p class="small">Each character maps to a unique center frequency between 4‚Äì12 kHz. We emit an up‚Äëchirp (~600 Hz span) per symbol, with a brief preamble for timing and small inter‚Äësymbol gaps. Decoder segments by time and scores energy along each chirp path (Goertzel). Plaintext is always sealed using AES‚ÄëGCM with a key derived from your passphrase (PBKDF2‚ÄëSHA256 with random salt). The binary payload (version+salt+IV+ciphertext) is Base32‚Äëencoded (RFC 4648, no padding) so it fits our limited alphabet (A‚ÄìZ and 2‚Äì7).</p>
  <div class="small">Keyboard shortcut: <span class="kbd">Ctrl/‚åò</span> + <span class="kbd">Enter</span> to generate WAV.</div>
</section>

<footer class="small" style="text-align:center;margin:18px 0 8px">¬© <span id="year"></span> Sonar ‚Ä¢ <a href="https://github.com/drs-az/Sonar/" style="text-decoration: none; color:white;" target="_blank">Open Source</a></footer>

    <div id="modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal-content">
        <h3 id="modalTitle">Notice</h3>
        <p id="modalMessage"></p>
        <div class="modal-actions">
          <button id="modalClose" class="btn ghost" type="button">Close</button>
        </div>
      </div>
    </div>
  </div><script>
// ===== Parameters =====
const SAMPLE_RATE = 44100;
// Extended charset: A‚ÄìZ, space, digits 2‚Äì7 (Base32 alphabet w/out padding) ‚Üí total 33 symbols
const SYMBOLS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 234567";
const SYM_TO_IDX = (()=>{ const map={}; for(let i=0;i<SYMBOLS.length;i++){ map[SYMBOLS[i]] = i; } return map; })();
const IDX_TO_SYM = [...SYMBOLS];
const SYMBOL_DURATION = 0.12;   // seconds
const GAP_DURATION = 0.01;      // seconds
const CHIRP_SPAN = 600;         // Hz
const F_MIN = 4000;
const F_MAX = 12000;
const N_SYMS = SYMBOLS.length;  // 33
const CENTER_FREQS = Array.from({length:N_SYMS}, (_,i)=>F_MIN + (i*(F_MAX - F_MIN - CHIRP_SPAN))/(N_SYMS-1));
const PREAMBLE = [ {f:8000,d:0.09}, {f:6000,d:0.09}, {f:10000,d:0.09}, {f:7000,d:0.09}, {f:9000,d:0.09} ];
const PREAMBLE_GAP = 0.06;

// ===== UI =====
document.getElementById('year').textContent = new Date().getFullYear();

// ===== Utils =====
function hann(n){ const w=new Float32Array(n); for(let i=0;i<n;i++){ w[i]=0.5*(1-Math.cos(2*Math.PI*i/(n-1))); } return w; }
function clamp(v,lo,hi){ return Math.min(hi, Math.max(lo, v)); }

// ===== Passphrase Strength =====
const MIN_PASS_SCORE = 3; // Fair or better
const PASS_CLASSES = ['strength-weak','strength-fair','strength-strong','strength-excellent'];

function evaluatePassphrase(pass){
  if(!pass){
    return {
      score: 0,
      label: 'Required',
      color: 'var(--muted)',
      cssClass: '',
      meetsMin: false,
      suggestions: ['Enter a passphrase to proceed.']
    };
  }

  let score = 0;
  const suggestions = [];
  const length = pass.length;

  if(length >= 16) score += 3;
  else if(length >= 12) score += 2;
  else if(length >= 8) score += 1;
  else suggestions.push('Use at least 8 characters.');

  const categories = [/[a-z]/, /[A-Z]/, /[0-9]/, /[^0-9A-Za-z]/].reduce((count, regex)=> count + (regex.test(pass) ? 1 : 0), 0);
  if(categories >= 4) score += 2;
  else if(categories >= 3) score += 1;
  else suggestions.push('Mix upper/lowercase letters, numbers, or symbols.');

  if(/(.)\1{2,}/.test(pass)) suggestions.push('Avoid repeating characters.');
  else score += 1;

  if(/^[A-Za-z]+$/.test(pass) && length < 14) suggestions.push('Include numbers or symbols for extra entropy.');

  let label='Very weak', color='#ff6b6b', cssClass='strength-weak';
  if(score >= 6){ label='Excellent'; color='#38d996'; cssClass='strength-excellent'; }
  else if(score >= 5){ label='Strong'; color='#38d996'; cssClass='strength-strong'; }
  else if(score >= 3){ label='Fair'; color='#f5c542'; cssClass='strength-fair'; }
  else if(score >= 2){ label='Weak'; color='#ff9f43'; cssClass='strength-weak'; }

  const meetsMin = score >= MIN_PASS_SCORE;
  return {score, label, color, cssClass, meetsMin, suggestions};
}

function updatePassFeedback(inputEl, feedbackEl){
  const evaluation = evaluatePassphrase(inputEl.value);
  PASS_CLASSES.forEach(cls=>inputEl.classList.remove(cls));
  if(evaluation.cssClass) inputEl.classList.add(evaluation.cssClass);
  const suggestionText = evaluation.suggestions.length ? evaluation.suggestions.join(' ') : (evaluation.label === 'Required' ? '' : 'Looking good.');
  const detail = suggestionText ? ` ‚Äì ${suggestionText}` : '';
  feedbackEl.innerHTML = `<strong>Strength: ${evaluation.label}</strong>${detail}`;
  feedbackEl.style.color = evaluation.color;
  return evaluation;
}

// WAV writer (PCM16)
function floatTo16BitPCM(float32){
  const len = float32.length; const out = new DataView(new ArrayBuffer(len*2));
  let offset = 0; for(let i=0;i<len;i++){ let s = clamp(float32[i], -1, 1); out.setInt16(offset, s < 0 ? s*0x8000 : s*0x7FFF, true); offset += 2; }
  return out;
}
function encodeWAV(samples, sampleRate=SAMPLE_RATE){
  const numFrames = samples.length; const blockAlign = 2; const byteRate = sampleRate * blockAlign; const dataSize = numFrames * blockAlign;
  const buffer = new ArrayBuffer(44 + dataSize); const view = new DataView(buffer);
  writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + dataSize, true); writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true); view.setUint16(34, 16, true);
  writeString(view, 36, 'data'); view.setUint32(40, dataSize, true);
  const pcm = floatTo16BitPCM(samples); for(let i=0;i<dataSize;i++) view.setInt8(44+i, pcm.getInt8(i));
  return new Blob([view], {type:'audio/wav'});
}
function writeString(view, offset, str){ for(let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i)); }
function concatFloat32(buffers){ const total = buffers.reduce((s,b)=>s+b.length,0); const out = new Float32Array(total); let o=0; for(const b of buffers){ out.set(b,o); o+=b.length; } return out; }

// ===== Base32 (RFC 4648, no padding) without regex =====
const B32_ALPH = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
const B32_MAP = (()=>{ const map={}; for(let i=0;i<B32_ALPH.length;i++){ map[B32_ALPH[i]] = i; } return map; })();
function base32Encode(buf){
  const bytes = buf instanceof Uint8Array ? buf : new Uint8Array(buf);
  let bits=0, value=0, output='';
  for(let i=0;i<bytes.length;i++){
    value = (value<<8) | bytes[i]; bits += 8;
    while(bits >= 5){ output += B32_ALPH[(value >>> (bits-5)) & 31]; bits -= 5; }
  }
  if(bits>0){ output += B32_ALPH[(value << (5-bits)) & 31]; }
  return output; // no padding
}
function stripWhitespace(str){
  let out = '';
  for(const ch of str){
    if(ch !== '\n' && ch !== '\r' && ch !== '\t' && ch !== ' ') out += ch;
  }
  return out;
}
function base32Decode(str){
  const s = stripWhitespace(str).toUpperCase();
  let bits=0, value=0; const out=[];
  for(let i=0;i<s.length;i++){
    const c = s[i]; const v = B32_MAP[c]; if(v===undefined) throw new Error('Invalid Base32 char: '+c);
    value = (value<<5) | v; bits += 5;
    if(bits>=8){ out.push((value >>> (bits-8)) & 255); bits -= 8; }
  }
  return new Uint8Array(out);
}

// ===== Crypto: AES‚ÄëGCM 256 + PBKDF2‚ÄëSHA256 =====
const subtle = (window.crypto && window.crypto.subtle) || (window.msCrypto && window.msCrypto.subtle);
async function deriveKey(pass, salt){
  const enc = new TextEncoder();
  const keyMaterial = await subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return subtle.deriveKey({name:'PBKDF2', salt, iterations: 120000, hash:'SHA-256'}, keyMaterial, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
}
async function aesEncrypt(plaintext, pass){
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(pass, salt);
  const ct = new Uint8Array(await subtle.encrypt({name:'AES-GCM', iv}, key, enc.encode(plaintext)));
  // Pack: [version=1][salt16][iv12][ct]
  const packed = new Uint8Array(1 + salt.length + iv.length + ct.length);
  let o=0; packed[o++]=1; packed.set(salt,o); o+=salt.length; packed.set(iv,o); o+=iv.length; packed.set(ct,o);
  return base32Encode(packed); // uppercase alphabet (A‚ÄìZ,2‚Äì7)
}
async function aesDecrypt(b32, pass){
  const data = base32Decode(b32);
  if(data[0] !== 1) throw new Error('Unsupported format');
  const salt = data.slice(1, 17);
  const iv = data.slice(17, 29);
  const ct = data.slice(29);
  const key = await deriveKey(pass, salt);
  const ptBuf = await subtle.decrypt({name:'AES-GCM', iv}, key, ct);
  return new TextDecoder().decode(ptBuf);
}

// ===== DSP: Synthesis & Decoding =====
function makeChirp(centerF, duration){
  const n = Math.floor(duration * SAMPLE_RATE); const y = new Float32Array(n); const w = hann(n);
  const f0 = Math.max(100, centerF - CHIRP_SPAN/2); const f1 = centerF + CHIRP_SPAN/2;
  for(let i=0;i<n;i++){
    const t = i / SAMPLE_RATE; const f = f0 + (f1 - f0) * (t/duration);
    const phase = 2*Math.PI*( f0*t + 0.5*(f1-f0)*(t*t)/duration ); y[i] = Math.sin(phase) * w[i];
  }
  return y;
}
function encodeTextToAudio(text){
  const clean = [...text.toUpperCase()].filter(c=>SYM_TO_IDX[c]!==undefined).join("");
  const parts = [];
  for(const p of PREAMBLE) parts.push(makeChirp(p.f, p.d));
  parts.push(new Float32Array(Math.floor(PREAMBLE_GAP*SAMPLE_RATE)));
  for(const ch of clean){ const idx = SYM_TO_IDX[ch]; const f = CENTER_FREQS[idx]; parts.push(makeChirp(f, SYMBOL_DURATION)); parts.push(new Float32Array(Math.floor(GAP_DURATION*SAMPLE_RATE))); }
  let audio = concatFloat32(parts); let mx = 0; for(const v of audio) mx = Math.max(mx, Math.abs(v)); if(mx>0) for(let i=0;i<audio.length;i++) audio[i] = 0.85*audio[i]/mx; return audio;
}
function movingEnergy(x, frame = Math.floor(0.05*SAMPLE_RATE), hop = Math.floor(0.01*SAMPLE_RATE)){
  const energies=[]; for(let i=0;i+frame<=x.length;i+=hop){ let s=0; for(let k=0;k<frame;k++) s+= x[i+k]*x[i+k]; energies.push(s); } return {energies, hop};
}
function findStartIndex(x){ const {energies, hop} = movingEnergy(x); if(!energies.length) return 0; const sorted=[...energies].sort((a,b)=>a-b); const thr = sorted[Math.floor(0.85*sorted.length)] || 0; for(let i=0;i<energies.length;i++) if(energies[i]>thr) return Math.max(0, i*hop - Math.floor(0.2*SAMPLE_RATE)); return 0; }
function goertzelPower(segment, sampleRate, freq){ const n=segment.length; if(n===0) return 0; const k = Math.round(0.5 + (n*freq)/sampleRate); const w=2*Math.PI*k/n; const cos=Math.cos(w); const coeff=2*cos; let s0=0,s1=0,s2=0; for(let i=0;i<n;i++){ s0 = segment[i] + coeff*s1 - s2; s2=s1; s1=s0; } const power = s1*s1 + s2*s2 - coeff*s1*s2; return power/n; }
function chirpBandEnergy(segment, centerF){ const half=CHIRP_SPAN/2; const taps=5; let sum=0; for(let i=0;i<taps;i++){ const a=i/(taps-1); const f=(centerF - half) + a*(2*half); sum += goertzelPower(segment, SAMPLE_RATE, f); } return sum; }
function decodeAudioToText(x){ let pos = findStartIndex(x); const preDur = PREAMBLE.reduce((s,p)=>s+p.d,0) + PREAMBLE_GAP; pos += Math.floor(preDur*SAMPLE_RATE); const symN = Math.floor(SYMBOL_DURATION*SAMPLE_RATE); const step = symN + Math.floor(GAP_DURATION*SAMPLE_RATE); const out=[]; while(pos + symN <= x.length){ const seg = x.subarray(pos, pos+symN); let peak=0; for(let i=0;i<seg.length;i++) peak = Math.max(peak, Math.abs(seg[i])); if(peak < 1e-3) break; let bestIdx=0, bestE=-1; for(let i=0;i<CENTER_FREQS.length;i++){ const e = chirpBandEnergy(seg, CENTER_FREQS[i]); if(e>bestE){ bestE=e; bestIdx=i; } } out.push(IDX_TO_SYM[bestIdx] || '?'); pos += step; } return out.join('').trim(); }

async function decodeFileToFloat32(file){
  const arrayBuf = await file.arrayBuffer(); const AC = window.AudioContext || window.webkitAudioContext; const ctx = new AC({ sampleRate: SAMPLE_RATE });
  const audioBuf = await new Promise((resolve,reject)=>{ ctx.decodeAudioData(arrayBuf.slice(0), b=>resolve(b), e=>reject(e)); });
  const data = audioBuf.getChannelData(0); const copy = new Float32Array(data.length); copy.set(data); ctx.close(); return copy;
}

// ===== Wire up controls =====
const textIn = document.getElementById('textIn');
const btnEncode = document.getElementById('btnEncode');
const encPass = document.getElementById('encPass');
const btnPlay = document.getElementById('btnPlay');
const player = document.getElementById('player');
const downloadLink = document.getElementById('downloadLink');
const fileIn = document.getElementById('fileIn');
const decPass = document.getElementById('decPass');
const btnDecode = document.getElementById('btnDecode');
const decodedPre = document.getElementById('decoded');
const modal = document.getElementById('modal');
const modalMessage = document.getElementById('modalMessage');
const modalClose = document.getElementById('modalClose');
const encPassFeedback = document.getElementById('encPassFeedback');
const decPassFeedback = document.getElementById('decPassFeedback');

let encPassEvaluation = updatePassFeedback(encPass, encPassFeedback);
let decPassEvaluation = updatePassFeedback(decPass, decPassFeedback);

encPass.addEventListener('input', ()=>{ encPassEvaluation = updatePassFeedback(encPass, encPassFeedback); });
decPass.addEventListener('input', ()=>{ decPassEvaluation = updatePassFeedback(decPass, decPassFeedback); });

function showModal(message){
  modalMessage.textContent = message;
  modal.classList.remove('hidden');
  requestAnimationFrame(()=>modalClose.focus());
}

function hideModal(){
  modal.classList.add('hidden');
}

modalClose.addEventListener('click', hideModal);
modal.addEventListener('click', (event)=>{ if(event.target === modal) hideModal(); });
window.addEventListener('keydown', (event)=>{ if(event.key === 'Escape' && !modal.classList.contains('hidden')) hideModal(); });

let currentUrl = null;

btnEncode.addEventListener('click', async ()=>{
  const pass = encPass.value || '';
  encPassEvaluation = updatePassFeedback(encPass, encPassFeedback);
  if(!pass) {
    showModal('Passphrase is required to create the WAV.');
    return;
  }
  if(!encPassEvaluation.meetsMin){
    const advice = encPassEvaluation.suggestions.join(' ') || 'Try a longer passphrase with more character variety.';
    showModal('Passphrase is too weak. ' + advice);
    return;
  }

  btnEncode.disabled = true;
  decodedPre.textContent='';
  try{
    const plaintext = textIn.value || 'HELLO WORLD';
    const payload = await aesEncrypt(plaintext, pass); // Base32 (A‚ÄìZ,2‚Äì7)
    const audio = encodeTextToAudio(payload);
    const blob = encodeWAV(audio, SAMPLE_RATE);
    if(currentUrl) URL.revokeObjectURL(currentUrl); currentUrl = URL.createObjectURL(blob);
    player.src = currentUrl; btnPlay.disabled = false; downloadLink.href = currentUrl; downloadLink.style.display='inline-flex';
  }catch(e){ showModal('Encode error: ' + (e.message||e)); }
  finally{ btnEncode.disabled = false; }
});

btnPlay.addEventListener('click', ()=>{ if(player.src) player.play(); });

fileIn.addEventListener('change', ()=>{
  const hasFiles = fileIn.files && fileIn.files.length > 0;
  btnDecode.disabled = !hasFiles;
  decodedPre.textContent='';
});

btnDecode.addEventListener('click', async ()=>{
  const file = fileIn.files && fileIn.files[0]; if(!file) return;
  btnDecode.disabled = true; decodedPre.textContent='Decoding‚Ä¶';
  try{
    const pass = decPass.value || '';
    decPassEvaluation = updatePassFeedback(decPass, decPassFeedback);
    if(!pass){ decodedPre.textContent = 'Passphrase is required to decode.'; return; }
    const x = await decodeFileToFloat32(file);
    const txt = decodeAudioToText(x);
    try { const plain = await aesDecrypt(txt, pass); decodedPre.textContent = plain; }
    catch(err){ decodedPre.textContent = '(Decryption failed) Make sure the passphrase matches.'; }
  }catch(e){ decodedPre.textContent = 'Decode error: ' + (e.message||e); }
  finally{ btnDecode.disabled = false; }
});

// Keyboard shortcut: Ctrl/Cmd + Enter to encode
window.addEventListener('keydown', (e)=>{ if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){ btnEncode.click(); } });
</script></body>
</html>
