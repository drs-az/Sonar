<!DOCTYPE html><html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Text ⇄ Sonar • HTML + JavaScript</title>
<meta name="theme-color" content="#0b1020" />
<style>
  :root{
    --bg:#0b1020; --bg2:#0c1430; --card:#111b3a; --muted:#aab1c7; --ink:#eef2ff; --line:#223066; --accent:#6aa3ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--ink);background:radial-gradient(1200px 800px at 50% -10%, #1a2b6d33 0%, transparent 60%),linear-gradient(180deg,var(--bg),var(--bg2) 35%,var(--bg));}
  .container{max-width:980px;margin:0 auto;padding:24px 16px}
  header h1{margin:0;font-size:clamp(22px,3.8vw,32px);font-weight:800;letter-spacing:.2px;display:flex;align-items:center;gap:10px}
  header p{margin:.35rem 0 0;color:var(--muted)}
  .badge{display:inline-flex;gap:8px;align-items:center;background:#0e1a3f;border:1px solid var(--line);border-radius:999px;padding:6px 10px;color:#d9e2ff;font-size:12px;margin:10px 10px 0 0}
  .card{background:var(--card);border:1px solid var(--line);border-radius:18px;box-shadow:0 10px 30px #0005;padding:18px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  @media (max-width:860px){.grid{grid-template-columns:1fr}}
  h2{margin:0 0 8px;font-size:18px}
  .muted{color:var(--muted)}
  textarea, input[type="file"], .text{width:100%}
  textarea{min-height:110px;padding:14px;border-radius:12px;border:1px solid var(--line);background:#0d1634;color:var(--ink);outline:none}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .btn{appearance:none;border:none;border-radius:12px;padding:12px 16px;background:linear-gradient(180deg,#4b87ff,#2a67f7);color:#fff;font-weight:700;cursor:pointer;box-shadow:0 6px 18px #4a87ff55}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .btn.ghost{background:#162650;border:1px solid var(--line);box-shadow:none}
  audio{width:100%}
  .small{font-size:12px;color:var(--muted)}
  .tabs{display:flex;border-bottom:1px solid var(--line);margin-top:16px}
  .tab{padding:10px 14px;cursor:pointer;border:1px solid var(--line);border-bottom:none;border-radius:12px 12px 0 0;background:#0f1b3e;margin-right:6px;color:#cfe0ff}
  .tab.active{background:#192a59}
  .panel{display:none}
  .panel.active{display:block}
  .pill{font-size:11px;padding:3px 8px;border-radius:999px;background:#0f1b3c;border:1px solid #263469;color:#cfe0ff;margin-right:6px}
  .kbd{background:#0e1735;border:1px solid #2b3a73;border-radius:6px;padding:2px 6px;font-family:ui-monospace,Menlo,Consolas,monospace;color:#dfe7ff}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>
        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M3 12c3-3 6-3 9 0s6 3 9 0" stroke="#6aa3ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Text ⇄ Sonar (Chirp‑MFSK)
      </h1>
      <p class="muted">Create dolphin‑style chirp audio from text and decode uploads back to text. Pure HTML + JavaScript. Mobile‑friendly. No backend.</p>
      <span class="badge">Charset: A–Z + space</span>
      <span class="badge">44.1 kHz</span>
      <span class="badge">120 ms symbol</span>
      <span class="badge">4–12 kHz band</span>
    </header><div class="tabs" role="tablist">
  <button class="tab active" role="tab" aria-selected="true" aria-controls="encodePanel" id="tabEncode">Encode</button>
  <button class="tab" role="tab" aria-selected="false" aria-controls="decodePanel" id="tabDecode">Decode</button>
</div>

<section id="encodePanel" class="panel active" role="tabpanel" aria-labelledby="tabEncode">
  <div class="card" style="margin-top:8px">
    <h2>Text → Sonar WAV</h2>
    <p class="muted">Type your message and generate dolphin‑like chirps. Works offline.</p>
    <textarea id="textIn" placeholder="HELLO WORLD FROM DOM">HELLO WORLD FROM DOM</textarea>
    <div class="row" style="margin-top:12px">
      <button id="btnEncode" class="btn">Generate WAV</button>
      <button id="btnPlay" class="btn ghost" disabled>Play</button>
      <a id="downloadLink" class="btn ghost" download="sonar.wav" style="text-decoration:none;display:none">Download WAV</a>
    </div>
    <div style="height:10px"></div>
    <audio id="player" controls></audio>
    <p class="small">Tip: For best decoding, use the saved WAV. MP3 decoding is supported below, but lossy compression can smear high‑frequency sweeps.</p>
  </div>
</section>

<section id="decodePanel" class="panel" role="tabpanel" aria-labelledby="tabDecode">
  <div class="card" style="margin-top:8px">
    <h2>Audio (WAV/MP3) → Decoded Text</h2>
    <p class="muted">Upload a file produced by this encoder. WAV is most reliable; MP3 often works with clean audio.</p>
    <input type="file" id="fileIn" accept="audio/*" />
    <div class="row" style="margin-top:12px">
      <button id="btnDecode" class="btn" disabled>Decode</button>
    </div>
    <div style="height:10px"></div>
    <div class="pill">Decoded text</div>
    <pre id="decoded" class="mono" style="white-space:pre-wrap;min-height:80px"></pre>
  </div>
</section>

<section class="card" style="margin-top:16px">
  <h2>How it works</h2>
  <p class="small">Each character maps to a unique center frequency between 4–12 kHz. We emit a short up‑chirp (~600 Hz span) per symbol, with a brief preamble for timing and tiny inter‑symbol gaps. The decoder segments by time and scores energy along each chirp path (Goertzel). For noisy rooms or MP3, you can later add FEC, a stronger sync, and band‑pass filtering.</p>
  <div class="small">Keyboard shortcut: <span class="kbd">Ctrl/⌘</span> + <span class="kbd">Enter</span> to generate WAV.</div>
</section>

<footer class="small" style="text-align:center;margin:18px 0 8px">© <span id="year"></span> Sonar Codec • Client‑only demo</footer>

  </div><script>
// ===== Parameters =====
const SAMPLE_RATE = 44100;
const SYMBOLS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
const SYM_TO_IDX = Object.fromEntries([...SYMBOLS].map((c,i)=>[c,i]));
const IDX_TO_SYM = [...SYMBOLS];
const SYMBOL_DURATION = 0.12;   // seconds
const GAP_DURATION = 0.01;      // seconds
const CHIRP_SPAN = 600;         // Hz
const F_MIN = 4000;
const F_MAX = 12000;
const N_SYMS = SYMBOLS.length;  // 27
const CENTER_FREQS = Array.from({length:N_SYMS}, (_,i)=>F_MIN + (i*(F_MAX - F_MIN - CHIRP_SPAN))/(N_SYMS-1));
const PREAMBLE = [ {f:8000,d:0.09}, {f:6000,d:0.09}, {f:10000,d:0.09}, {f:7000,d:0.09}, {f:9000,d:0.09} ];
const PREAMBLE_GAP = 0.06;

// ===== UI =====
const tabEncode = document.getElementById('tabEncode');
const tabDecode = document.getElementById('tabDecode');
const encodePanel = document.getElementById('encodePanel');
const decodePanel = document.getElementById('decodePanel');

function setTab(which){
  const a = which==='encode';
  tabEncode.classList.toggle('active', a); tabEncode.setAttribute('aria-selected', String(a));
  tabDecode.classList.toggle('active', !a); tabDecode.setAttribute('aria-selected', String(!a));
  encodePanel.classList.toggle('active', a); decodePanel.classList.toggle('active', !a);
}

tabEncode.addEventListener('click', ()=> setTab('encode'));

tabDecode.addEventListener('click', ()=> setTab('decode'));

document.getElementById('year').textContent = new Date().getFullYear();

// ===== Utils =====
function hann(n){ const w=new Float32Array(n); for(let i=0;i<n;i++){ w[i]=0.5*(1-Math.cos(2*Math.PI*i/(n-1))); } return w; }
function clamp(v,lo,hi){ return Math.min(hi, Math.max(lo, v)); }

// WAV writer (PCM16)
function floatTo16BitPCM(float32){
  const len = float32.length;
  const out = new DataView(new ArrayBuffer(len*2));
  let offset = 0;
  for(let i=0;i<len;i++){
    let s = clamp(float32[i], -1, 1);
    out.setInt16(offset, s < 0 ? s*0x8000 : s*0x7FFF, true);
    offset += 2;
  }
  return out;
}
function encodeWAV(samples, sampleRate=SAMPLE_RATE){
  const numFrames = samples.length;
  const blockAlign = 2; // mono 16-bit
  const byteRate = sampleRate * blockAlign;
  const dataSize = numFrames * blockAlign;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, dataSize, true);
  const pcm = floatTo16BitPCM(samples);
  for(let i=0;i<dataSize;i++) view.setInt8(44+i, pcm.getInt8(i));
  return new Blob([view], {type:'audio/wav'});
}
function writeString(view, offset, str){ for(let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i)); }

function concatFloat32(buffers){
  const total = buffers.reduce((s,b)=>s+b.length,0);
  const out = new Float32Array(total);
  let o=0; for(const b of buffers){ out.set(b,o); o+=b.length; }
  return out;
}

// ===== DSP: Synthesis =====
function makeChirp(centerF, duration){
  const n = Math.floor(duration * SAMPLE_RATE);
  const y = new Float32Array(n);
  const w = hann(n);
  const f0 = Math.max(100, centerF - CHIRP_SPAN/2);
  const f1 = centerF + CHIRP_SPAN/2;
  for(let i=0;i<n;i++){
    const t = i / SAMPLE_RATE;
    const f = f0 + (f1 - f0)*(t/duration);
    const phase = 2*Math.PI*( f0*t + 0.5*(f1-f0)*(t*t)/duration );
    y[i] = Math.sin(phase) * w[i];
  }
  return y;
}

function encodeTextToAudio(text){
  const clean = [...text.toUpperCase()].filter(c=>SYM_TO_IDX[c]!==undefined).join("");
  const parts = [];
  for(const p of PREAMBLE) parts.push(makeChirp(p.f, p.d));
  parts.push(new Float32Array(Math.floor(PREAMBLE_GAP*SAMPLE_RATE)));
  for(const ch of clean){
    const idx = SYM_TO_IDX[ch];
    const f = CENTER_FREQS[idx];
    parts.push(makeChirp(f, SYMBOL_DURATION));
    parts.push(new Float32Array(Math.floor(GAP_DURATION*SAMPLE_RATE)));
  }
  let audio = concatFloat32(parts);
  let mx = 0; for(const v of audio) mx = Math.max(mx, Math.abs(v));
  if(mx>0) for(let i=0;i<audio.length;i++) audio[i] = 0.85*audio[i]/mx;
  return audio;
}

// ===== DSP: Decoding =====
function movingEnergy(x, frame = Math.floor(0.05*SAMPLE_RATE), hop = Math.floor(0.01*SAMPLE_RATE)){
  const energies=[]; for(let i=0;i+frame<=x.length;i+=hop){ let s=0; for(let k=0;k<frame;k++) s+= x[i+k]*x[i+k]; energies.push(s); }
  return {energies, hop};
}
function findStartIndex(x){
  const {energies, hop} = movingEnergy(x);
  if(!energies.length) return 0;
  const sorted = [...energies].sort((a,b)=>a-b);
  const thr = sorted[Math.floor(0.85*sorted.length)] || 0;
  for(let i=0;i<energies.length;i++) if(energies[i]>thr) return Math.max(0, i*hop - Math.floor(0.2*SAMPLE_RATE));
  return 0;
}
function goertzelPower(segment, sampleRate, freq){
  const n = segment.length; if(n===0) return 0;
  const k = Math.round(0.5 + (n*freq)/sampleRate);
  const w = 2*Math.PI*k/n; const cos = Math.cos(w); const coeff = 2*cos;
  let s0=0,s1=0,s2=0; for(let i=0;i<n;i++){ s0 = segment[i] + coeff*s1 - s2; s2=s1; s1=s0; }
  const power = s1*s1 + s2*s2 - coeff*s1*s2; return power/n;
}
function chirpBandEnergy(segment, centerF){
  const half = CHIRP_SPAN/2; const taps = 5; let sum=0;
  for(let i=0;i<taps;i++){ const a=i/(taps-1); const f = (centerF - half) + a*(2*half); sum += goertzelPower(segment, SAMPLE_RATE, f); }
  return sum;
}
function decodeAudioToText(x){
  let pos = findStartIndex(x);
  const preDur = PREAMBLE.reduce((s,p)=>s+p.d,0) + PREAMBLE_GAP;
  pos += Math.floor(preDur*SAMPLE_RATE);
  const symN = Math.floor(SYMBOL_DURATION*SAMPLE_RATE);
  const step = symN + Math.floor(GAP_DURATION*SAMPLE_RATE);
  const out = [];
  while(pos + symN <= x.length){
    const seg = x.subarray(pos, pos+symN);
    let peak=0; for(let i=0;i<seg.length;i++) peak = Math.max(peak, Math.abs(seg[i]));
    if(peak < 1e-3) break;
    let bestIdx=0, bestE=-1;
    for(let i=0;i<CENTER_FREQS.length;i++){
      const e = chirpBandEnergy(seg, CENTER_FREQS[i]); if(e>bestE){ bestE=e; bestIdx=i; }
    }
    out.push(IDX_TO_SYM[bestIdx] || '?');
    pos += step;
  }
  return out.join('').trim();
}

async function decodeFileToFloat32(file){
  const arrayBuf = await file.arrayBuffer();
  const AC = window.AudioContext || window.webkitAudioContext; // mp3/wav decoder
  const ctx = new AC({ sampleRate: SAMPLE_RATE });
  const audioBuf = await new Promise((resolve,reject)=>{ ctx.decodeAudioData(arrayBuf.slice(0), b=>resolve(b), e=>reject(e)); });
  const data = audioBuf.getChannelData(0);
  const copy = new Float32Array(data.length); copy.set(data);
  ctx.close();
  return copy;
}

// ===== Wire up controls =====
const textIn = document.getElementById('textIn');
const btnEncode = document.getElementById('btnEncode');
const btnPlay = document.getElementById('btnPlay');
const player = document.getElementById('player');
const downloadLink = document.getElementById('downloadLink');
const fileIn = document.getElementById('fileIn');
const btnDecode = document.getElementById('btnDecode');
const decodedPre = document.getElementById('decoded');

let currentUrl = null;

btnEncode.addEventListener('click', ()=>{
  btnEncode.disabled = true; decodedPre.textContent='';
  try{
    const audio = encodeTextToAudio(textIn.value || 'HELLO WORLD');
    const blob = encodeWAV(audio, SAMPLE_RATE);
    if(currentUrl) URL.revokeObjectURL(currentUrl);
    currentUrl = URL.createObjectURL(blob);
    player.src = currentUrl; btnPlay.disabled = false;
    downloadLink.href = currentUrl; downloadLink.style.display='inline-flex';
  }catch(e){ alert('Encode error: '+ (e.message||e)); }
  finally{ btnEncode.disabled = false; }
});

btnPlay.addEventListener('click', ()=>{ if(player.src) player.play(); });

fileIn.addEventListener('change', ()=>{ btnDecode.disabled = !fileIn.files?.length; decodedPre.textContent=''; });

btnDecode.addEventListener('click', async ()=>{
  const file = fileIn.files?.[0]; if(!file) return;
  btnDecode.disabled = true; decodedPre.textContent='Decoding…';
  try{
    const x = await decodeFileToFloat32(file);
    const text = decodeAudioToText(x);
    decodedPre.textContent = text || '(no symbols detected)';
  }catch(e){ decodedPre.textContent = 'Decode error: ' + (e.message||e); }
  finally{ btnDecode.disabled = false; }
});

// Keyboard shortcut: Ctrl/Cmd + Enter to encode
window.addEventListener('keydown', (e)=>{
  if((e.ctrlKey || e.metaKey) && e.key === 'Enter'){ btnEncode.click(); }
});
</script></body>
</html>
